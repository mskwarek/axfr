\chapter{Implementacja}
Przeanalizowanie problemu postawionego w niniejszej pracy magisterskiej wymagało implementacji własnych narzędzi. Jak wcześniej wspomniano, programy dostępne w sieci są bardzo dobre (dig \cite{dig}, axfr-tool \cite{git_axfr_tool}, robotex \cite{robotex}) jednak nie zapewniają oczekiwanej wydajności. Wynika to z faktu, że są one nastawione głównie na analizę konkretnego przypadku. Narzędzia są używane głównie przez pentesterów, których typowym zadaniem jest przetestowanie pod kątem bezpieczeństwa pewnej aplikacji, gdzie liczba serwerów DNS jak i testowanych domen jest mocno ograniczona. Proces ten sam w sobie jest niezwykle złożony i często wymaga nawet tygodni pracy, dlatego czas w jakim wykonywał się będzie program sprawdzający podatności DNS nie jest aż tak istotny. Oczywiście mówimy o różnicy w czasie w granicach do kilku minut. W podejściu prezentowanym w tej pracy założono, że przeanalizuje się możliwie jak najwięcej domen dostępnych w sieci internet. Dlatego też różnica procesowania jednej pary domena -- adres IP serwera autorytatywnego już nawet na poziomie kilku sekund pozwala zaobserwować bardzo duży skok wydajności. 

Dojście do rozwiązania optymalnego nie było zbyt oczywiste. Początkowe rozwiązania opierały się na próbach nabudowania managera zarządzającego procesami w których uruchamiane były zewnętrzne narzędzia -- głównie dig. Rozwiązanie takie miało szereg zalet, na przykład było bardzo skalowalne i łatwe do zrealizowania. Niestety okazało się, że menedżer zarządzający procesami wymaga zbyt dużej ilości zasobów, a głównie pamięci RAM, dlatego wymuszone zostało zrezygnowanie z tego podejścia. 

\section{Dane wejściowe}
Dane wejściowe programu zostały pozyskane od grupy naukowców z TU Delft\cite{deflt} w formie par adres WWW strony oraz adres IP jej serwera autorytarnego. Lista w takim formacie przechowywana była w pliku tekstowym. Zgromadzono w nim ponad 5 miliardów wpisów uporządkowanych w kolejności alfabetycznej, a ich łączny rozmiar przekraczał 130 gigabajtów.

\section{Zaimplementowane narzędzia}
Przeprowadzenie globalnego skanu niosło za sobą szereg konsekwencji. Przede wszystkim tylko niektóre programy umożliwiają w ogóle procesowanie tak dużych plików. Dodatkowo, zakładając, że średnio należy przeznaczyć na skanowanie jednej domeny około 3 sekund okazało się, że przeprocesowanie całego pliku zajęłoby odpowiednio:
$$3(s) * 5 * 10^{9} = 25 * 10^{8}(min) = \frac{25}{60} * 10^{8}(h) = 41.67 * 10^{6} (dni)$$.
Opierając się na opisanym wyżej rozumowaniu, podjęto decyzję, że należy procesować pary (adres WWW, adres IP) równolegle. Podjętych zostało kilka prób implementacji odpowiedniego narzędzia umożliwiającego przeprowadzenie badań w zadowalającym czasie:
\begin{itemize}
	\item narzędzie oparte na programie dig skryptach powłoki bash,
	\item menadżer procesów programu dig oparty na skryptach języka Python,
	\item skaner AXFR (C-AXFR) wspomagany skryptami powłoki bash.
\end{itemize}
Szczegółowo zostaną one opisane w kolejnych punktach tego rozdziału.

\subsection{Program dig zarządzany skryptami powłoki}
Pierwszym rozwiązaniem, które powstało w ramach pracy nad opisywanym problemem był skaner AXFR oparty na programie dig\cite{isc}. Program skupia się wokół protokołu DNS i umożliwia wykonywanie zapytań różnych typów\cite{Liu:2006:DB:1197828}. Ponadto, jest prosty w obsłudze, daje duże możliwości jeśli chodzi o budowanie zapytań DNS oraz bardzo często dostępny jest domyślnie w wielu dystrybucjach systemów operacyjnych Linux. 

Odpowiedzi uzyskane dzięki programowi miały być zapisywane do plików tekstowych. Każda, potencjalnie uzyskana odpowiedź miała być zapisywana do oddzielnego pliku tekstowego, aby wykluczyć równoczesne użycie tego samego zasobu przez wiele procesów. Rozwiązanie tego typu działa oraz z powodzeniem przeskanowano kilka tysięcy domen, jednak okazało się zbyt wolne do zastosowania na szerszą skalę a także występowały kłopoty z zapotrzebowaniem na zasoby (mowa tu głównie o pamięci operacyjnej). Bliźniacze podejście zostało zastosowane w opisywanym wcześniej projekcie skanowania domen z listy \textit{Alexa 1 Milion}\cite{scans.io}.

\subsection{Menedżer procesów zarządzany skryptami języka Python}
Kolejną próbą rozwiązania problemu ogromej liczby danych do przeskanowania była implementacja skanera w języku skryptowym Python. Próba ta podyktowana była kilkoma istotnymi aspektami. Pierwszym z nich jest implementacja tak zwanych ,,programowych'' wątków w standardowej bibliotece tego języka. Umożliwiło to implementację mechanizmu, który pozwolił sprawdzić, czy maszyna dysponuje takimi zasobami, które pozwolą na uruchomienie kolejnego wątku skanującego. Dodatkowym atutem jest tu także możliwość wywoływania poleceń powłoki systemu Linux ze skryptu języka Python, a więc możliwe było wykorzystanie istniejącej już implementacji programu dig\cite{isc}.

Niestety podobnie jak we wcześniej opisywanym punkcie, problemem okazały się ograniczenia czasowe spowodowane niewystarczającą ilością zasobów. Program został przestestowany podczas kilkudniowego skanowania i zdołano odpowiednio:
\begin{itemize}
	\item przeanalizować kilka milionów par (adres WWW, adres IP),
	\item pozyskać dane do wstępnej analizy podatności w skali globalnej,
	\item dwukrotnie zawiesić maszynę na której wykonywano badania.
\end{itemize}

Pomimo, że implementacja w języku Python nie okazała się na tyle wydajna aby wykorzystać ją w badaniach przeprowadzonych w ramach tej pracy magisterskiej, jest to dobrze narzędzie dla pasjonatów bezpieczeństwa sieciowego, którzy chcą skanować wiele serwerów. Podejście takie zaprezentowane jest w kilku projektach, które można znaleźć w serwiesie github\cite{github-axfr}.

\subsection{Skaner C-AXFR}
Ostatecznie zdecydowano się na napisanie własnego narzędzia umożliwiającego transfer strefy DNS. Wybór padł na język programowania C \cite{clanguage} w wersji standardu c03 \cite{c03std}. Oczywiście aplikacje pisane w języku C nie należą do rozwiązań prostych, jednak są bardzo dobrym kompromisem pomiędzy wysokim poziomem abstrakcji modeli programistycznych i łatwością dostępu do interfejsów sieciowych. Ponadto język C charakteryzuje się dość dobrą szybkością działania, ze względu na kompilację kodów źródłowych do kodu binarnego. Kryterium szybkości działania było jednym z kluczowych przy implementacji, co pokazały poprzednie próby implementacji.

Rolę danych wejściowych programu mogą pełnić odpowiednio:
\begin{enumerate}
	\item plik tekstowy w formacie \textit{adres\_domeny}|\textit{IP\_serwera\_autorytatywnego},
	\item para parametrów wejściowych podanych w odpowiedniej kolejności - \textit{adres\_domeny IP\_serwera\_autorytatywnego}. 
\end{enumerate}
Zdecydowano się na takie rozróżnienie z prostego powodu. Autor rozwiązania chciał zachować podobieństwo tworzonego rozwiązania do programu dig, który jest wykorzystywany przez wiele osób. Dodatkowo, dużo łatwiej można testować logikę programu na małych porcjach danych i opcja numer 2. została w pewnym sensie funckją debugową. Jako wspomniane dane testowe najczęściej wykorzystywana była domena \textit{zonetransfer.me}\cite{zonetransfer}, której autor specjalnie umożliwia transfer strefy, aby uzmysłowić innym ludziom zagrożenie wynikające z niepowołanego korzystania.

Logika programu jest bardzo prosta. Początkowo budowana jest jednostka APDU protokołu DNS z odpowiednimi danymi, a w szczególności z poprawnie ustawioną flagą \textit{qtype} odpowiedzialną za identyfikację rodzaju zapytania DNS. Co ważne, mechanizm AXFR wymaga używania nietypowego dla DNS protokołu TCP.

Komunikacja z serwerami autorytatywnymi została oparta na blokujących socketach. Dodatkowo, zaimplementowany został autorski mechanizm pozwalający na wykorzystywanie timeoutów podczas łączenia się z serwerem. Wymagało to przełączania socketu na tryb pracy nieblokujący. Dokładny algorytm działania został przedstawiony na rysunku \ref{}.

Algorytm postępowania w przypadku odebrania pakietu danych przedstawiony jest na rysunku\ref{}. Dane odbierane z interfejsu sieciowego są zapisane w systemie szesnastkowym, zgodnie z zaleceniami znanymi z dokumentu RFC 1035\cite{RFC1035}. Program umożliwia parsowanie najbardziej popularny i najczęściej używanych rekordów RR, czyli:
\begin{enumerate}
	\item A
	\item AAAA
	\item CNAME
	\item HINFO
	\item TXT
	\item ... .
\end{enumerate} 

Dodatkowo, jeśli zostanie odebrany typ który nie został przewidziany w implementacji parsera to wszystkie dane odczytane z socketa zostaną przeniesione w formie zapisu heksadecymalnego do pliku z odpowiedzią. Zapewnia ta kompatybilność z innymi rozszerzeniami protokołu DNS oraz zabezpiecza przed błędnym wykluczeniem niektórych informacji ze skanowania. Jeśli pojawi się nieznany wcześniej typ rekordu z bazy danych DNS, to będzie można interpretować go podczas analizy konkretnych odpowiedzi od serwera.

Tak jak wcześniej wspomniano, transfer strefy DNS wykorzystuje protokół TCP, który nie jest tak powszechnie stosowany jeśli chodzi o Doman Name System. Wpływa to pośrednio na to, jakie wyniki możemy uzyskać przy próbie odpytania serwera o jego strefę. Mowa tu o trzech charakterystycznych sytuacjach, mianowicie:
\begin{enumerate}
	\item brak możliwości nawiązania połączenia na warstwie 4 (TCP) na porcie 53,
	\item uzyskanie połączenia w rozumieniu protokołu TCP na porcie 53 i brak możliwoście transferu danych,
	\item uzyskanie połączenia TCP na porcie 53 i pomyślny transfer danych.
\end{enumerate}

Początkowo założono, że uzyskanie już samego połączenia TCP z serwerem może być ciekawym przedmiotem badania. Interfejs serwera autorytatywnego danej domeny powinien umożliwiać swoim klientom tylko kilka podstawowych operacji, jak na przykład rozwiązanie nazwy domenowej komputera ze swojej strefy. Do takich działań połączenie TCP nie powinno być potrzebne. Dodatkowo, port 53 na którym działa DNS jest zarezerwowany tylko dla tego protokołu, więc nie powinno udostępniać się na nim innych usług. Dowodzi to temu, że sytuacja, gdy możliwe jest nawiązanie połączenia TCP na porcie 53 jest nienaturalna i niezgodna z panującymi dobrymi praktykami. Właśnie dlatego, w pierwszej implementacji skanera założono, że program będzie tworzył puste pliki w przypadku opisanym w tym akapicie. Niestety, Zjawisko to okazało się tak powszechne, że powstały duże problemy związane z wydajnością skanera. Mowa tu o dostępie poszczególnych procesów do dysku twardego maszyny na której były one uruchomione. Dlatego też zdecydowano się na zapisywanie informacji jedynie o domenach, które odpowiedziały na zapytanie AXFR a sytuację umożliwiania nawiązywania sesji TCP na porcie 53 pozostawia się do analizy podczas przyszłych badań.

